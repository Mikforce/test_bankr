Технологии и инструменты:
Язык программирования: Python 3.x (основной язык разработки).
Обработка и распознавание документов (Модуль 2):
OCR (для PDF/сканов):
Tesseract OCR с Python-оберткой pytesseract: Бесплатное, открытое решение. Для улучшения качества можно использовать предобработку изображений с помощью OpenCV (например, бинаризация, удаление шума, выравнивание).
Cloud-based OCR (альтернатива для высокого качества): Google Cloud Vision AI, AWS Textract. Эти сервисы часто дают более точные результаты, особенно для сложных макетов, но требуют интернет-соединения и платные.
Для PDF с текстовым слоем: PyPDF2 или pdfminer.six для извлечения текста напрямую, минуя OCR.
Парсинг структурированных данных (для Excel/Word):
Excel: pandas (для .xlsx, .xls, .csv).
Word: python-docx (для .docx).
Анализ разметки и извлечение сущностей (NER):
SpaCy или NLTK: для поиска именованных сущностей (ФИО, адреса, даты, суммы, наименования организаций) в тексте, извлеченном OCR.
Регулярные выражения (re): для поиска специфических паттернов (ИНН, СНИЛС, номера паспорта).
Layout-aware модели (продвинутый вариант): Модели типа LayoutLM, Donut (от Naver Clova) – это трансформеры, обученные понимать структуру документа. Их можно дообучить на примерах анкет и других документов для более точного извлечения пар "ключ-значение".
Структурирование и нормализация данных (Модуль 3):
Pydantic: для определения моделей данных и валидации. Это поможет обеспечить, что все необходимые поля получены и имеют корректный тип.
Кастомные функции валидации: для проверки специфических форматов (например, контрольная сумма ИНН, СНИЛС), диапазонов дат и т.д.
Интеллектуальное заполнение (Модуль 4):
База знаний/Правила: Набор правил, определяющих, какие данные из каких источников должны попадать в какие поля заявления. Это может быть реализовано через словари сопоставления, конфигурационные файлы (YAML/JSON) или даже небольшую базу данных.
Large Language Models (LLM) - опционально, для сложных случаев: Можно использовать LLM (например, дообученную модель GPT-семейства или открытые модели типа Llama 2, Mixtral) для "понимания" контекста и более сложного сопоставления данных, особенно если структура входных документов сильно варьируется. Это потребует careful prompting и, возможно, RAG (Retrieval Augmented Generation) с базой знаний юридических формулировок.
Генерация заявления (Модуль 5):
Шаблонизаторы: Jinja2 в связке с python-docx-template (для .docx) или reportlab (для .pdf). Создается шаблон заявления с плейсхолдерами, которые заполняются извлеченными и структурированными данными.
Формат заявления: Предпочтительно .docx, так как он легко редактируется юристами перед подачей в суд.
Как будет происходить обработка и распознавание документов?
Загрузка: Клиент загружает документы (сканы паспорта, СНИЛС, ИНН, справки о доходах, выписки по счетам, кредитные договоры, анкету в Excel/Word и т.д.).
Классификация (опционально, но полезно): Простая модель классификации (например, на основе имен файлов или даже контента с помощью TF-IDF + SVM/LogisticRegression) может помочь определить тип документа, чтобы применить соответствующий парсер/OCR-настройки.
Извлечение текста/данных:
Для PDF/сканов:
Если PDF содержит текстовый слой, текст извлекается напрямую.
Если PDF/изображение – применяется OCR. Изображения могут предварительно обрабатываться для улучшения качества OCR (увеличение контрастности, удаление шума, выравнивание).
После OCR, с помощью NLP (NER, regex) извлекаются ключевые сущности: ФИО, дата рождения, паспортные данные, адреса, ИНН, СНИЛС, информация о доходах, кредиторах, суммах задолженности и т.д.
Для Excel/Word (анкеты): Данные парсятся напрямую с использованием pandas и python-docx. Ожидается, что анкеты имеют более-менее стандартизированную структуру (например, определенные названия колонок/полей).
Агрегация и структурирование: Все извлеченные данные собираются в единую структуру (например, JSON-объект или объект Pydantic-модели), представляющую профиль клиента. На этом этапе происходит разрешение конфликтов (например, если ФИО немного отличается в разных документах – можно выбрать наиболее часто встречающийся вариант или тот, что из паспорта). Данные приводятся к каноническому виду (например, даты в YYYY-MM-DD).
Валидация: Проверяется полнота и корректность данных. Если критически важные данные отсутствуют или невалидны, система может выдать предупреждение.
Как будет реализована генерация заявления?
Шаблон: Заранее подготавливается юридически выверенный шаблон заявления о банкротстве в формате .docx (например, с использованием python-docx-template). Шаблон содержит плейсхолдеры (например, {{ client_fio }}, {{ client_address }}, {{ creditor_name_1 }}, {{ debt_amount_1 }} и т.д.).
Контекст данных: Структурированные и валидированные данные клиента (полученные на предыдущих шагах) передаются в шаблонизатор Jinja2 в виде словаря (контекста).
Рендеринг: Шаблонизатор заполняет плейсхолдеры в шаблоне значениями из контекста. Это включает не только простые подстановки, но и условные блоки (например, если есть дети – добавляется соответствующий раздел), циклы (для перечисления кредиторов, имущества).
Формирование документа: Готовый документ сохраняется в формате .docx.
Человеческий контроль: Сгенерированное заявление обязательно должно проходить проверку юристом перед подачей в суд. Система должна позиционироваться как инструмент для подготовки черновика.